# 秒杀

> 参考：[秒杀设计开篇](https://time.geekbang.org/column/article/40153)

> 参考：[秒杀架构原则](https://time.geekbang.org/column/article/40726)

> 参考：[高并发秒杀系统](https://blog.csdn.net/CSDN_Terence/article/details/77744042)

> 参考：[面试之秒杀问题](http://www.voidcn.com/article/p-dkhmifwx-co.html)


## 架构
秒杀其实就是大量的`并发读`和`并发写`。

秒杀架构图
![](resources/秒杀架构图.jpg)


## 前端
1. 页面元素尽量简单，静态化，存储于CDN
```
   静态数据做缓存：缓存到离用户最近的地方
   1. 用户浏览器中
   2. CDN中
   3. 服务端Cache中
```
2. 请求后端的请求数尽量少，即合并请求
3. 页面做好动静分离，用户秒杀时不刷新整个页面，而只刷新抢宝按钮
> 参考：[动静分离](https://time.geekbang.org/column/article/40727)
4. 按钮点击一次后置灰，防止用户频繁点击，避免大量的重复请求
5. 跳转到秒杀页面时先强制用户登陆/注册，提前获取用户信息并缓存
6. 增加秒杀答题，防止机器抢单，且可把瞬时的大流量按时间铺开


## 后端
1. 流量削峰（消息队列）
```
无损方案：

   1.排队
实现：消息队列
用消息队列来缓冲瞬时流量，一端承接瞬时的流量洪峰，另一端平滑地将消息推送出去。
把同步的直接调用转换成异步的间接推送，把“一步的操作”变成“两步的操作”，其中增加的一步起到缓冲的作用。

   2.答题
实现：图片验证码；简单的随机小题目。
增加购买的复杂度，一是为了防止买家使用秒杀器参与秒杀，即防止机器作弊行为；
二是把峰值的大量请求拉长，比如把之前1秒内的请求延长到2～10秒内，即把请求峰值基于时间分片，通过延缓请求来减轻服务端压力。
这样，大量请求从瞬时并发而来，变成先后顺序而来，那靠后的请求到来时自然也没有库存了，
因此根本到不了最后的下单步骤，真正的并发写就非常有限了，从而大大减轻了服务器压力。

   3.分层过滤
用“漏斗式”设计来处理请求，在不同的层次尽可能过滤掉无效请求，让漏斗最末端的才是有效请求。
```
分层过滤图
![](resources/分层过滤.jpg)

```
有损方案：

   服务降级：对超出服务负载能力的请求做降级，以起到强制限流的作用。   
```

```
业务方案：

   在削峰这件事上，除了采用技术手段，还可以采用业务手段来达到一定效果。
   比如在零点大促时刻，可以采用发放秒杀优惠券、发起抽奖活动等方式，将一部分流量分散到别处。
```

> 参考：[流量削峰](https://time.geekbang.org/column/article/40736)

2. 缓存记录每位用户的请求数：一位用户只准请求一次

3. 缓存记录秒杀产品的详情信息
   
   缓存记录秒杀产品的库存量：卖空后则直接返回失败（系统限流保护）
```
   产品的信息，如详情、库存等，属于“热点数据”。

1. 静态热点数据
   通过业务手段（如卖家报名）或技术手段（如大数据预测），提前把热点商品筛选出来，提前缓存。
   缺点：增加卖家的使用成本；实时性较差。

2. 动态热点数据
   收集交易链路上各环节中的热点Key（Nginx，Cache，RPC框架等一些中间件产品已有热点统计模块），
   然后上游系统把收集的热点数据发送到热点服务中心，通过交易链路上各个系统访问的时间差
  （商品详情、购物车、订单、支付、库存、物流等），把热点透传给下游系统，下游提前做好热点保护。

注意：热点服务中心应异步抓取和分析热点日志，不应影响业务系统的主流程；
     热点发现要做到接近实时（比如3秒内），只有接近实时，动态发现才有意义。

```

![](resources/热点数据.jpg)

```
热点保护

   1. 热点优化
   缓存热点数据

   2. 热点限制
   对商品ID做一致性hash，根据hash结果做分桶，每个分桶一个处理队列。
   这样可以把热点商品限制在一个请求队列里，防止热点商品占用太多的服务器资源。

   3. 热点隔离
   不要让1%的热点请求影响到99%的日常请求。
   隔离后也更方便对这1%的热点请求做针对性优化。
   
   1）业务隔离：秒杀活动提前报名，预知热点。
   2）系统隔离：申请单独域名；单独部署服务集群。
   3）数据隔离：启用单独的Cache集群或数据库。

```

> 参考：[热点数据](https://time.geekbang.org/column/article/40729)

4. 下单后减库存
   1. 通过数据库的事务机制来扣减库存，保证库存数的强一致性
   2. 如果并发量太大，可采用应用层排队扣减库存，防止热点请求占用太多的数据库连接
   3. 订单超时补库存
   4. 支付失败补库存
   5. 扣完/补完数据库中的库存后，记得更新缓存中的库存
```   
库存缓存：
   1. 缓存中的库存数只需保证最终一致性，不需要非常准确，即多放了一些请求过去也无妨。
   2. 等到真正减库存的时候，则需保证数据库中库存数的强一致性，不然就是“超卖”。
   3. 缓存中最终一致性的并发读，既解决了强一致性读的瓶颈，又过滤了一些无效请求减少了后面的并发写。
```
```
超卖：
   1. 如果业务不是严格要求不能超卖，则付款数万一超过库存数，则可通过补货来解决。
   2. 如果业务严格要求不能超卖，则应严格控制付款数不能超过库存数，否则会带来损失。
```
```
反作弊措施：
   1. 识别经常下单但不付款的买家（对此类买家打标签，下单时不减库存）
   2. 设置商品的单人最大购买数目（如：参加秒杀的商品一人最多购买3件）
```

> 参考：[扣减库存](https://time.geekbang.org/column/article/40743)

5. 数据库：主从备份，读写分离

## 部署
1. 秒杀系统单独部署
2. 服务节点横向扩展
3. 避免单点：集群部署 + 服务无状态化

## 延伸
1. 准备兜底方案 (There's always a Plan B)
   1. 降级：牺牲一些次要的功能和用户体验，用有限的系统资源来保证核心业务流程的稳定。
   2. 限流：当系统容量达到瓶颈时，限制一部分流量来保护系统（客户端限流；服务端限流）。
   3. 拒绝服务：Nginx过载保护，负载达到阈值后拒绝http请求；服务端过载时直接返回错误。
2. 利用热点数据 (热点的发现与隔离，不仅对秒杀这个场景有意义，对其他的高性能分布式系统也非常有价值)
3. 越追求极致性能，系统的定制开发就会越多，同时系统的通用性就会越差。

> 参考：[兜底方案](https://time.geekbang.org/column/article/40744)

> 参考：[优化性能](https://time.geekbang.org/column/article/40742)

> 参考：[答疑解惑](https://time.geekbang.org/column/article/68247)

