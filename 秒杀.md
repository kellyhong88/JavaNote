# 秒杀

> 参考：[秒杀设计开篇](https://time.geekbang.org/column/article/40153)

> 参考：[秒杀架构原则](https://time.geekbang.org/column/article/40726)

> 参考：[高并发秒杀系统](https://blog.csdn.net/CSDN_Terence/article/details/77744042)

> 参考：[面试之秒杀问题](http://www.voidcn.com/article/p-dkhmifwx-co.html)


## 架构
秒杀其实就是大量的`并发读`和`并发写`。

![](resources/秒杀架构图.jpg)


## 前端
1. 页面元素尽量简单，静态化，存储于CDN
```
   静态数据做缓存：缓存到离用户最近的地方
   1. 用户浏览器中
   2. CDN中
   3. 服务端Cache中
```
2. 请求后端的请求数尽量少，即合并请求
3. 页面做好动静分离，用户秒杀时不刷新整个页面，而只刷新抢宝按钮
> 参考：[动静分离](https://time.geekbang.org/column/article/40727)
4. 按钮点击一次后置灰，防止用户频繁点击，避免大量的重复请求
5. 跳转到秒杀页面时先强制用户登陆/注册，提前获取用户信息并缓存
6. 增加秒杀答题，防止机器抢单，且可把瞬时的大流量按时间铺开


## 后端
1. 流量削峰（消息队列）
```
无损方案：
   1.排队
实现：消息队列
用消息队列来缓冲瞬时流量，一端承接瞬时的流量洪峰，另一端平滑地将消息推送出去。
把同步的直接调用转换成异步的间接推送，把“一步的操作”变成“两步的操作”，其中增加的一步起到缓冲的作用。
   2.答题
实现：图片验证码；简单的随机小题目。
增加购买的复杂度，一是为了防止买家使用秒杀器参与秒杀，即防止机器作弊行为；二是把峰值的大量请求拉长，比如把之前1秒内的请求延长到2～10秒内，即把请求峰值基于时间分片，通过延缓请求来减轻服务端压力。
这样，大量请求从瞬时并发而来，变成先后顺序而来，那靠后的请求到来时自然也没有库存了，因此根本到不了最后的下单步骤，真正的并发写就非常有限了，从而大大减轻了服务器压力。
   3.分层过滤

有损方案：
   1.强制限流
   2.负载保护   
```
> 参考：[流量削峰](https://time.geekbang.org/column/article/40736)
2. 缓存记录每位用户的请求数：一位用户只准请求一次
3. 缓存记录秒杀产品的库存量：卖空后则直接返回失败（系统限流保护）
   产品库存属于“热点数据”
> 参考：[热点数据](https://time.geekbang.org/column/article/40729)
4. 下单后减库存
   1. 订单超时补库存
   2. 支付失败补库存
   3. 扣/补完数据库中的库存后，更新缓存中的库存
> 参考：[扣减库存](https://time.geekbang.org/column/article/40743)

5. 数据库：主从备份，读写分离

## 部署
1. 秒杀系统单独部署
2. 服务节点横向扩展
3. 避免单点：集群部署 + 服务无状态化

## 延伸
1. 准备兜底方案，备案 planB
2. 利用热点数据
3. 越追求极致性能，系统的定制开发就会越多，同时系统的通用性就会越差。

> 参考：[兜底方案](https://time.geekbang.org/column/article/40744)

> 参考：[答疑解惑](https://time.geekbang.org/column/article/68247)

> 参考：[优化性能](https://time.geekbang.org/column/article/40742)

